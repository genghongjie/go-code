package main

import (
	"encoding/json"
	"fmt"
	"github.com/genghongjie/go-code/middleware/kafka/util"
	"math/rand"
	"os"
	"time"

	"github.com/confluentinc/confluent-kafka-go/kafka"
)

type student struct {
	Id   int    `json:"id"`
	Age  int    `json:"age"`
	Name string `json:"name"`
}
type AutoGenerated struct {
	IP          string `json:"ip"`
	Hostname    string `json:"hostname"`
	Appname     string `json:"appname"`
	Domain      string `json:"domain"`
	ContextID   int64  `json:"context_id"`
	Timestamp   string `json:"timestamp"`
	Network     string `json:"network"`
	IsSucc      int    `json:"is_succ"`
	ErrorNo     string `json:"error_no"`
	ErrorInfo   string `json:"error_info"`
	IsResp      int    `json:"is_resp"`
	RzyResponse string `json:"rzy_response"`
	UserIP      string `json:"user_ip"`
	InternalIP  string `json:"internal_ip"`
	Providerip  string `json:"PROVIDERIP"`
	OpBranchNo  string `json:"op_branch_no"`
	FundAccount string `json:"fund_account"`
	MachineCode string `json:"machine_code"`
	ClientVer   string `json:"client_ver"`
	BranchNo    string `json:"branch_no"`
	Action1     string `json:"ACTION1"`
	MobileIdfv  string `json:"mobile_idfv"`
	TerminalOs  string `json:"terminal_os"`
	Date        string `json:"date"`
	RequestNo   string `json:"request_no"`
	RespTime    int    `json:"resp_time"`
}
type AutoGenerated2 struct {
	TransactionID string  `json:"transaction_id"`
	SubTransType  string  `json:"sub_trans_type"`
	PortDst       int     `json:"port_dst"`
	PSrc          string  `json:"p_src"`
	Transcode     string  `json:"transcode"`
	PortSrc       int     `json:"port_src"`
	Sempno        string  `json:"sempno"`
	TransCount    int     `json:"trans_count"`
	PDst          string  `json:"p_dst"`
	Cap           string  `json:"cap"`
	SuccCount     int     `json:"succ_count"`
	RespCount     int     `json:"resp_count"`
	Spv           string  `json:"spv"`
	Wtfs          string  `json:"wtfs"`
	Fengongsi     string  `json:"fengongsi"`
	RetCode       string  `json:"ret_code"`
	Ts            int     `json:"ts"`
	TransType     string  `json:"trans_type"`
	RequestNo     string  `json:"request_no"`
	Date          string  `json:"date"`
	ReqCount      int     `json:"req_count"`
	ErrInfo       string  `json:"err_info"`
	Timestamp     string  `json:"timestamp"`
	Appname       string  `json:"appname"`
	RespTime      float64 `json:"resp_time"`
	FundAccount   string  `json:"fund_account"`
}

func main() {

	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "Usage: %s <config-file-path>\n",
			os.Args[0])
		os.Exit(1)
	}
	configFile := os.Args[1]
	conf := util.ReadConfig(configFile)

	//topic := "_confluent-ksql-kafka_command_topic"
	//topic := "purchases"
	topic := "kafka_to_clickhouse"
	p, err := kafka.NewProducer(&conf)

	if err != nil {
		fmt.Printf("Failed to create producer: %s", err)
		os.Exit(1)
	}

	// Go-routine to handle message delivery reports and
	// possibly other event types (errors, stats, etc)
	go func() {
		for e := range p.Events() {
			switch ev := e.(type) {
			case *kafka.Message:
				if ev.TopicPartition.Error != nil {
					fmt.Printf("Failed to deliver message: %v\n", ev.TopicPartition)
				} else {
					fmt.Printf("Produced event to topic %s: key = %-10s value = %s\n",
						*ev.TopicPartition.Topic, string(ev.Key), string(ev.Value))
				}
			}
		}
	}()

	//users := [...]string{"eabara", "jsmith", "sgarcia", "jbernard", "htanaka", "awalther"}
	//items := [...]string{"book", "alarm clock", "t-shirts", "gift card", "batteries"}

	//可选的chan Event，可以用来监听发送的结果
	delivery_chan := make(chan kafka.Event, 10000)

	for n := 0; n < 1000000; n++ {
		fmt.Println(rand.Intn(2))
		intR := rand.Intn(300)

		time.Sleep(time.Duration(intR) * time.Millisecond)
		//key := users[rand.Intn(len(users))]
		//data := items[rand.Intn(len(items))]
		//p.Produce(&kafka.Message{
		//	TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
		//	Key:            []byte(key),
		//	Value:          []byte(data),
		//}, delivery_chan)
		//
		//s := student{
		//	Id:   1,
		//	Age:  18,
		//	Name: "Hank",
		//}
		//bb, _ := json.Marshal(s)
		//p.Produce(&kafka.Message{
		//	TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
		//	//Key:            []byte(key),
		//	Value: bb,
		//}, delivery_chan)

		tt := AutoGenerated{
			IP:       "192.168.32.1",
			Hostname: "jq-clj- 202",
			Appname:  "zsbwj",
			//Appname:     "zsbwj",
			Domain:      "ops",
			ContextID:   1657336647025537540,
			Timestamp:   "2022-07-09 11:17:08.631 +0800",
			Network:     "10.80.8",
			IsSucc:      rand.Intn(2),
			ErrorNo:     "-65021",
			ErrorInfo:   "尊敬 的客户",
			IsResp:      1,
			RzyResponse: "ok",
			UserIP:      "nulle",
			InternalIP:  "null",
			Providerip:  "10.80.8.30.2843",
			OpBranchNo:  "406",
			FundAccount: "2345678_9",
			MachineCode: "null",
			ClientVer:   "null",
			BranchNo:    "406",
			Action1:     "登录",
			MobileIdfv:  "null",
			TerminalOs:  "null",
			Date:        "2022-07-09",
			RequestNo:   "200",
			RespTime:    0,
		}

		ttt, _ := json.Marshal(tt)
		p.Produce(&kafka.Message{
			TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
			//Key:            []byte(key),
			Value: ttt,
		}, delivery_chan)

		tt2 := AutoGenerated2{
			TransactionID: "111",
			SubTransType:  "10.80.6",
			PortDst:       2001,
			PSrc:          "10.80.6.200",
			Transcode:     "2190004",
			PortSrc:       62136,
			Sempno:        "None",
			TransCount:    1,
			PDst:          "10.80.6.90",
			Cap:           "cap2",
			SuccCount:     rand.Intn(2),
			RespCount:     1,
			Spv:           "app2",
			Wtfs:          "None",
			Fengongsi:     "上海",
			RetCode:       "0",
			Ts:            1657785367,
			TransType:     "光大基金查询功能号-2190002",
			RequestNo:     "2190002",
			Date:          "2022-07-14",
			ReqCount:      0,
			ErrInfo:       "IT",
			Timestamp:     "2022-07-14 15:56:07.000 +0800",
			Appname:       "jzjys",
			RespTime:      1.47,
			FundAccount:   "null",
		}

		ttt2, _ := json.Marshal(tt2)
		p.Produce(&kafka.Message{
			TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
			//Key:            []byte(key),
			Value: ttt2,
		}, delivery_chan)

		tt3 := AutoGenerated2{
			TransactionID: "112",
			SubTransType:  "10.80.6",
			PortDst:       2001,
			PSrc:          "10.80.6.200",
			Transcode:     "2190001",
			PortSrc:       62136,
			Sempno:        "None",
			TransCount:    1,
			PDst:          "10.80.6.90",
			Cap:           "cap2",
			SuccCount:     rand.Intn(2),
			RespCount:     1,
			Spv:           "app1",
			Wtfs:          "None",
			Fengongsi:     "徐州",
			RetCode:       "0",
			Ts:            1657785367,
			TransType:     "光大证券查询功能号-2190001",
			RequestNo:     "2190001",
			Date:          "2022-07-14",
			ReqCount:      0,
			ErrInfo:       "IT",
			Timestamp:     "2022-07-14 15:56:07.000 +0800",
			Appname:       "jzjys",
			RespTime:      1.47,
			FundAccount:   "null",
		}

		ttt3, _ := json.Marshal(tt3)
		p.Produce(&kafka.Message{
			TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
			//Key:            []byte(key),
			Value: ttt3,
		}, delivery_chan)

		tt4 := AutoGenerated2{
			TransactionID: "112",
			SubTransType:  "10.80.6",
			PortDst:       2001,
			PSrc:          "10.80.6.200",
			Transcode:     "2190001",
			PortSrc:       62136,
			Sempno:        "None",
			TransCount:    1,
			PDst:          "10.80.6.90",
			Cap:           "cap2",
			SuccCount:     rand.Intn(2),
			RespCount:     1,
			Spv:           "app3",
			Wtfs:          "None",
			Fengongsi:     "南京",
			RetCode:       "0",
			Ts:            1657785367,
			TransType:     "光大证券查询功能号-2190000",
			RequestNo:     "2190000",
			Date:          "2022-07-14",
			ReqCount:      0,
			ErrInfo:       "IT",
			Timestamp:     "2022-07-14 15:56:07.000 +0800",
			Appname:       "jzjys",
			RespTime:      1.47,
			FundAccount:   "null",
		}

		ttt4, _ := json.Marshal(tt4)
		p.Produce(&kafka.Message{
			TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
			//Key:            []byte(key),
			Value: ttt4,
		}, delivery_chan)

	}
	//监听结果
	e := <-delivery_chan
	m := e.(*kafka.Message)
	if m.TopicPartition.Error != nil {
		fmt.Printf("Delivery failed: %v\n", m.TopicPartition.Error)
	} else {
		fmt.Printf("Delivered message to topic %s [%d] at offset %v\n",
			*m.TopicPartition.Topic, m.TopicPartition.Partition, m.TopicPartition.Offset)
	}
	close(delivery_chan)
	// Wait for all messages to be delivered
	p.Flush(15 * 1000)
	p.Close()
}
